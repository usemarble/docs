---
title: "Next.js"
description: "Integrate Marble in your Next.js application"
---

Getting your content to your Next.js site is as simple as making an API request to the Marble API. This guide will walk you through setting up a blog with Marble and Next.js.

If you want to get started quickly, you can clone our [Next.js blog template](https://github.com/taqh/nextjs-example).

<Steps>
<Step title="Set up environment variables">
First, you'll need to add your Marble API URL and Workspace Key to your environment variables. Create a `.env.local` file in the root of your Next.js project and add the following:

```bash .env.local
MARBLE_API_URL=https://api.marblecms.com/v1
MARBLE_WORKSPACE_KEY=your_workspace_key_here
```

<Warning>
  **Important:** Never expose your `MARBLE_WORKSPACE_KEY` in client-side code.
  Your environment variables should only be accessed on the server during the
  build process. For client-side updates, use [webhooks](/content/guides/webhooks) to
  trigger rebuilds.
</Warning>

<Tip>
You can find your Workspace Key in your Marble dashboard under the settings for your workspace.
</Tip>
</Step>

<Step title="Create API utility functions">
To make it easier to fetch data from Marble, you can create a utility file to wrap your API calls. This keeps your data-fetching logic organized and reusable.

Create a file at `lib/query.ts` (or `.js` if you're using JavaScript).

<Note>
For complete TypeScript type definitions, see our [TypeScript Types reference](/content/api-reference/types). The server functions below use these types for full type safety.
</Note>

```typescript lib/query.ts
import type { MarbleAuthorList, MarbleCategoryList, MarblePost, MarblePostList, MarbleTagList } from '@/types/marble';

const url = process.env.MARBLE_API_URL;
const key = process.env.MARBLE_WORKSPACE_KEY;

export async function getPosts() {
  try {
    const raw = await fetch(`${url}/${key}/posts`);
    const data: MarblePostList = await raw.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

export async function getTags() {
  try {
    const raw = await fetch(`${url}/${key}/tags`);
    const data: MarbleTagList = await raw.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

export async function getSinglePost(slug: string) {
  try {
    const raw = await fetch(`${url}/${key}/posts/${slug}`);
    const data: MarblePost = await raw.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

export async function getCategories() {
  try {
    const raw = await fetch(`${url}/${key}/categories`);
    const data: MarbleCategoryList = await raw.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

export async function getAuthors() {
  try {
    const raw = await fetch(`${url}/${key}/authors`);
    const data: MarbleAuthorList = await raw.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

```

</Step>

<Step title="Display a list of posts">
Now you can use the `getPosts` function in a Next.js page to fetch and display a list of your blog posts. For example, in `app/blog/page.jsx`:

```jsx app/blog/page.jsx
import { getPosts } from "@/lib/query";

// Revalidate this page every hour
export const revalidate = 3600;

export default async function BlogPage() {
  const { posts } = await getPosts();

  return (
    <section>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <a href={`/blog/${post.slug}`}>{post.title}</a>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

</Step>

<Step title="Display a single post">
To display a single post, you can create a dynamic route in Next.js, for example at `app/blog/[slug]/page.jsx`. This page will use the `getSinglePost` function to fetch the content for a specific post.

```jsx app/blog/[slug]/page.jsx
import { getSinglePost } from "@/lib/query";

export default async function PostPage({ params }) {
  const { post } = await getSinglePost(params.slug);

  return (
    <div>
      <h1>{post.title}</h1>
      <article dangerouslySetInnerHTML={{ __html: post.content }} />
    </div>
  );
}
```

<Info>
  **A note on `dangerouslySetInnerHTML`**
  
  We use `dangerouslySetInnerHTML` to render the HTML content of your post. Marble sanitizes all HTML content before it's sent to you, so you can be confident that it's safe to render in your application.
</Info>
</Step>

<Step title="Example Styling (Optional)">
To improve the appearance of your content, you can use Tailwind CSS Typography to add beautiful typographic defaults. We provide a simple `Prose` component that makes it easy to style your Marble content.

First, install the Tailwind CSS Typography plugin:

```bash
npm install -D @tailwindcss/typography
```

Add it to your Tailwind CSS configuration. If you're using Tailwind CSS v4:

```css app/globals.css
@import "tailwindcss";
@plugin "@tailwindcss/typography";
```

For Tailwind CSS v3, add it to your `tailwind.config.js`:

```javascript tailwind.config.js
module.exports = {
  theme: {
    // ...
  },
  plugins: [
    require('@tailwindcss/typography'),
    // ...
  ],
}
```

Now create a `Prose` component that you can use to style your content. Create `components/prose.tsx`:

```tsx components/prose.tsx
import { cn } from '@/lib/utils';
import type { HTMLAttributes } from 'react';

type ProseProps = HTMLAttributes<HTMLElement> & {
  as?: 'article';
  html: string;
};

export function Prose({ children, html, className }: ProseProps) {
  return (
    <article
      className={cn(
        'prose prose-h1:font-bold prose-h1:text-xl prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl prose-headings:font-serif prose-headings:font-normal mx-auto',
        className
      )}
    >
      {html ? <div dangerouslySetInnerHTML={{ __html: html }} /> : children}
    </article>
  );
}

```

<Info>
  **Note:** This component assumes you have a `cn` utility function for combining class names. You can install and set up `clsx` or use a similar utility, or simply replace `cn()` with string concatenation.
</Info>

Now you can update your post page to use the `Prose` component:

```jsx app/blog/[slug]/page.jsx
import { getSinglePost } from "@/lib/query";
import { Prose } from "@/components/prose";

export default async function PostPage({ params }) {
  const { post } = await getSinglePost(params.slug);

  return (
    <div>
      <h1>{post.title}</h1>
      <Prose html={post.content} />
    </div>
  );
}
```

This will give your content beautiful, readable typography with proper spacing, font sizes, and styling for headings, links, images, and other elements. You can customize the styles by modifying the classes in the `Prose` component or by extending the typography configuration in your Tailwind config.

For more information about customizing the typography styles, check out [Tailwind CSS Typography](https://github.com/tailwindlabs/tailwindcss-typography)!
</Step>
</Steps>
